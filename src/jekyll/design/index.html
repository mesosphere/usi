<!DOCTYPE html>
<!--==============================================================================
	           "GitHub HTML5 Pandoc Template" v1.2 — by Tristano Ajmone           
	==============================================================================
	(c) Tristano Ajmone, 2017, MIT License (MIT). Project's home repository:

	- https://github.com/tajmone/pandoc-goodies

	This template reuses source code taken from the following projects:

	- GitHub Markdown CSS: © Sindre Sorhus, MIT License (MIT):
	  https://github.com/sindresorhus/github-markdown-css

	- Primer CSS: © 2016 GitHub Inc., MIT License (MIT):
	  http://primercss.io/
	==============================================================================-->
<html>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title></title>
  <style type="text/css">@font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,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) format('woff')}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:16px;line-height:1.5;word-wrap:break-word;box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto;padding:45px}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body a{background-color:transparent;-webkit-text-decoration-skip:objects;color:#0366d6;text-decoration:none}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body h1{margin:.67em 0}.markdown-body img{border-style:none}.markdown-body svg:not(:root){overflow:hidden}.markdown-body code,.markdown-body kbd,.markdown-body pre{font-family:monospace,monospace}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body hr{box-sizing:content-box;overflow:hidden;background:0 0;border-bottom:1px solid #dfe2e5}.markdown-body hr::before{display:table;content:""}.markdown-body hr::after{display:table;clear:both;content:""}.markdown-body table{border-spacing:0;border-collapse:collapse;display:block;width:100%;overflow:auto}.markdown-body td,.markdown-body th{padding:0}.markdown-body blockquote{margin:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace}.markdown-body pre{font:12px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;word-wrap:normal}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body::before{display:table;content:""}.markdown-body::after{display:table;clear:both;content:""}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:0}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}.markdown-body blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body kbd{font-size:11px;box-shadow:inset 0 -1px 0 #959da5}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1{padding-bottom:.3em;font-size:2em;border-bottom:1px solid #eaecef}.markdown-body h2{padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #eaecef}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{font-size:.85em;color:#6a737d}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #dfe2e5}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body code{padding:.2em 0;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code::after,.markdown-body code::before{letter-spacing:-.2em;content:"\00a0"}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}.markdown-body pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code::after,.markdown-body pre code::before{content:normal}.markdown-body .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}.markdown-body kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fcfcfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5}.markdown-body :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.flash{position:relative;padding:16px;color:#246;background-color:#e2eef9;border:1px solid #bac6d3;border-radius:3px}.flash p:last-child{margin-bottom:0}.flash-messages{margin-bottom:24px}.flash-warn{color:#4c4a42;background-color:#fff9ea;border-color:#dfd8c2}.flash-error{color:#911;background-color:#fcdede;border-color:#d2b2b2}.flash-success{color:#22662c;background-color:#e2f9e5;border-color:#bad3be}.flash-plain{color:#4c4a42;background-color:#f5f5f5;border-color:#c1c1c1}</style>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article class="markdown-body">
<nav id="TOC">
<ul>
<li><a href="#intent-of-this-document">Intent of this document</a></li>
<li><a href="#terminology">Terminology:</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#schema">Schema</a></li>
<li><a href="#responsibilities-of-usi">Responsibilities of USI</a><ul>
<li><a href="#offer-match-statistics">Offer Match Statistics</a></li>
<li><a href="#storage-of-unrecoverable-facts-from-mesos">Storage of Unrecoverable Facts from Mesos</a></li>
<li><a href="#spurious-reservations-and-spurious-pods">Spurious reservations and spurious pods</a></li>
<li><a href="#constraints-application">Constraints Application</a></li>
<li><a href="#storage-and-message-ordering-guarantees">Storage and Message Ordering Guarantees</a></li>
<li><a href="#decoupling-scheduler-input-from-implementation-framework-state">Decoupling Scheduler Input from Implementation Framework State</a></li>
</ul></li>
<li><a href="#example-interaction-diagram">Example Interaction Diagram</a></li>
<li><a href="#questions">Questions</a></li>
<li><a href="#relevant-resources">Relevant Resources</a></li>
</ul>
</nav>
<h1 id="intent-of-this-document">Intent of this document</h1>
<p>This document is intended for developers of the Unified Scheduler Interface (USI) and implementation frameworks that will use it.</p>
<h1 id="terminology">Terminology:</h1>
<ul>
<li><strong>Unified Scheduler Interface (USI)</strong>: The scheduler component described in this document; an abstraction layer that receives specifications for pods to launch, and handles low level details with Mesos.</li>
<li><strong>Implementation Framework</strong>: Term used to refer to a framework that uses the USI. Contains orchestration logic and persistence logic pertinent to its logic domain.</li>
<li><strong>Scheduler command</strong>: Sent by the implementation framework to perform actions; launch pods, kill pods, etc.</li>
<li><strong>Pod</strong>: A collection of one or more tasks. In the USI (and this document), we deal only with pods. Things formerly known as &quot;apps&quot; or &quot;tasks&quot; are pods with 1 task, with slightly more supported launch options (Docker, etc.).</li>
<li><strong>Implementation Framework State</strong>: The state of a Framework as best modeled for the Framework's needs; for example, service specifications, deployment plans, etc.</li>
<li><strong>Orchestrator</strong>: The orchestrator functionality of a Framework as suited for the Framework's goals, dealing with the conditional evolution of framework state.</li>
<li><strong>RunSpec</strong>: Framework managed data structure used to communicate a launch recipe to the USI. Covers resource requirements, networking specification, and a factory to generate a Mesos CommandInfo in order to run one or more tasks.</li>
<li><strong>ReservationSpec</strong>: A data structure used to communicate with the USI that some reservation to be made, resized, or destroyed. This data structure is provided by the framework.</li>
</ul>
<h1 id="overview">Overview</h1>
<p>In this document we present a design for the USI, in order to support the creation of Frameworks with the following general design goals:</p>
<ul>
<li>Deterministic, even in the event of a crash.</li>
<li>High scale; can handle workloads with high volume of tasks and deployments.</li>
<li>Modular; frameworks can use only what it needs.</li>
<li>Stays responsive under large spikes of load.</li>
<li>Understandable by mortals (IE framework authors)</li>
<li>Help unify integration efforts with Mesos across the variety of Frameworks in the DC/OS ecosystem.</li>
<li>Provide a deterministic interface for launching pods.</li>
</ul>
<p>In an effort to achieve these goals, the following concepts will be employed, generally, in the design of USI:</p>
<ul>
<li>Fast, lock-less serial processing over concurrency.</li>
<li><a href="https://martinfowler.com/eaaDev/EventSourcing.html">Event sourcing</a> for the replication of state.</li>
<li>External-affecting decisions are made in response to the evolution of persisted state, and not in direct response to commands themselves.</li>
<li>State transitions and actions are decided upon by pure functions (scheduler has side-effects, decision to make a revive call made by a pure function which receives the current state; will make same decision every time.)</li>
</ul>
<p>At a high-level, there are three major groups of components involved in a framework using USI, and will roughly look like the following:</p>
<div class="figure">
<img src="./high-level-design.svg" />

</div>
<h1 id="schema">Schema</h1>
<p>As a rough general overview, schema in USI is expected to look something like this:</p>
<div class="figure">
<img src="./data-model.svg" />

</div>
<h1 id="responsibilities-of-usi">Responsibilities of USI</h1>
<p>The USI handle as much of the Mesos-specific pod management logic, and reservation logic, without performing any orchestration functions. As an overview, the USI will perform the following jobs:</p>
<ul>
<li>Given a set of pod specifications, launch those pods at-most once.
<ul>
<li>This includes offer matching, constraint evaluation, revive behavior, etc.</li>
</ul></li>
<li>Expose the state of those pods in replicable fashion.</li>
<li>Reconciles pod statuses with Mesos</li>
<li>Cache (persist) and expose non-recoverable facts about pods and reservation state so that those facts are known by future recovering framework processes</li>
<li>Manage reservations</li>
<li>Expose agent state changes, such as &quot;agent has begun a maintenance window and should drain&quot;.</li>
<li>Expose inverse-offer changes</li>
</ul>
<p>The USI will <em>not</em> perform these jobs:</p>
<ul>
<li>Automatically restarting pods</li>
<li>Orchestration logic, such as rolling deployment logic</li>
<li>Automatically killing unrecognized pods</li>
</ul>
<h2 id="offer-match-statistics">Offer Match Statistics</h2>
<p>In order to minimize the complexity in the scheduler, the USI will expose a stream of offer match events that can be aggregated by some other component as best serves the needs of the framework. A generic and standard way to do that is left for another design document.</p>
<h2 id="storage-of-unrecoverable-facts-from-mesos">Storage of Unrecoverable Facts from Mesos</h2>
<p>There are several pieces of state that cannot be reliably recovered from Mesos under certain unreachable scenarios, or under all scenarios. In order to support deterministic behavior in the framework in the event of a crash / recovery, the USI will store these facts so that the same decisions can be made.</p>
<h3 id="the-fact-that-we-sent-a-task-launch">The fact that we sent a task launch</h3>
<p>The USI has launch-at-most-once guarantees. In order to guarantee this in the event of a crash, we have to store the fact that we were about to launch some task on an agent before we actually do so, since, presumably, we could failover and not see the task we launched if the agent in question were unreachable. This needs confirmation, but our understanding is that the Mesos master only stores agent info, and not task info. It should be clarified that we don't need to store the full offer, or the full response; just the time and the agentId should suffice.</p>
<p>The time at which we sent the task launch request is also unrecoverable, and needed as an input for rate-limited launch scenarios.</p>
<h3 id="certain-taskstatus-attributes">Certain TaskStatus attributes</h3>
<p>Mesos does not retain the first time a task was unreachable, or the first time a Mesos health check was reported unhealthy.</p>
<h3 id="agent-info">Agent info</h3>
<p>Lamentably, the agent info can be forgotten by Mesos when it is unreachable for more than <code>agent_ping_timeout * max_agent_ping_timeouts</code>. Agent info is needed as an input for certain types of offer-matching constraints, such as the Marathon <code>MAX_PER</code> constraint or <code>UNIQUE</code> constraint.</p>
<p>If the Agent info is forgotten, the pods may still come back later (source: I tested this myself).</p>
<h3 id="certain-facts-about-reservations">Certain facts about reservations</h3>
<p>We'll store certain things about reservations, such as &quot;reservation last seen&quot;.</p>
<h2 id="spurious-reservations-and-spurious-pods">Spurious reservations and spurious pods</h2>
<p>A spurious pod and spurious reservation is defined as a pod or reservation belonging to the implementation framework for which there is no persistent record (PodRecord or ReservationRecord) of it being launched.</p>
<p>In the case of a spurious pod being discovered, the USI will expose a PodStatus for the spurious pod to the implementation framework.</p>
<p>Similarly, spurious pods pertaining to the framework may surface. Rather than automatically kill these pods, the scheduler component will expose their status as best as it can, so that the framework can best decide what to do with them (PodStatus without a PodRecord).</p>
<p>Unfortunately, Mesos does not expose task grouping information, but instead reports individual task statuses. As such, spurious tasks will be reported as PodStatuses with a task count of 1, each.not expose this information in TaskGroup.</p>
<h2 id="constraints-application">Constraints Application</h2>
<p>The scheduler component itself will provide an unopinionated, pluggable approach to the application of constraints. The USI will provide a library of predefined constraints available for use that the framework may optionally choose to use. Implementation frameworks will provide constraints to the USI via the RunSpec. The language for exposing these constraints to the end-user is left to the implementation framework.</p>
<h2 id="storage-and-message-ordering-guarantees">Storage and Message Ordering Guarantees</h2>
<p>In order to support deterministic behavior in implementation frameworks, Message ordering will be preserved. Were it not so, we could do things such as send Mesos task statuses out of order.</p>
<p>Some messages require data to be persisted before we can act on them. All messages, whether they affect the persisted state or not, will be threaded through the scheduler persistence layer.</p>
<p>This does not imply that we store offers.</p>
<h2 id="decoupling-scheduler-input-from-implementation-framework-state">Decoupling Scheduler Input from Implementation Framework State</h2>
<p>An implementation framework launches pods and creates reservations by specifying RunSpecs and ReservationSpecs. However, depending on the implementation framework, different aspects of this runSpec come from the user. For example, a user may specify memory requirements, but not specify the launch command or container image (this being managed by the implementation framework deploying a deta service of some kind).</p>
<p>Therefore, by design USI does not persist the runSpec. It only persists the record of launching pods or reservations.</p>
<h1 id="example-interaction-diagram">Example Interaction Diagram</h1>
<p>Implementation frameworks will be responsible for storing and maintaining what needs to be launched, and for handling orchestration logic; the scheduler solely handles the launching of pods (with at-least-once guarantees), and providing guarantees about which aspects of these pod states the implementation framework can get back. This has the following benefits:</p>
<ul>
<li><strong>Flexible framework schema</strong>: Implementation frameworks can store the information about tasks to launch and schedules as it suits the framework; it is not necessary for the USI to support every different orchestration concern under the sun</li>
<li><strong>Incremental adoption path</strong>: Scheduler component can be integrated in to any existing framework that can emit the appropriate launch commands with runSpecs; statuses emitted by scheduler can be mapped back to entities that the implementation framework understands.</li>
<li><strong>Generally solve the problem of deterministic orchestration</strong>: Implementation frameworks can rely on podRecords to ensure that an instance of some service isn't doubly launched in the event of failover.</li>
</ul>
<p>The following interaction diagram should help illustrate roughly how the scheduler component will interact with other layers.</p>
<div class="figure">
<img src="./scheduler-interaction.svg" />

</div>
<h1 id="questions">Questions</h1>
<h3 id="how-does-the-scheduler-notify-the-orchestrator-that-an-agent-is-going-away">How does the scheduler notify the orchestrator that an agent is going away?</h3>
<p>AgentInfo will be exposed via the podStatus. If the agent's information is detected to be updated, an PodStatus update will be emitted for all pods pertaining to the agent with the new agent information. The orchestrator can react to this new state and begin transitioning pods off the agent in a controlled fashion.</p>
<h3 id="what-about-pod-relaunch-rate-limiting">What about pod relaunch rate-limiting?</h3>
<p>This is an area that needs further consideration and design. To keep the scheduler component simple and concerns separated, ideally the scheduler knows nothing about backoff delay, and another component rate-limits launch commands in-transit according to the backoff mechanism.</p>
<p>We may also consider if configurable per-service rate limiters are even necessary, and potentially just throttle by pod ids globally.</p>
<h3 id="what-about-logging">What about logging?</h3>
<p>It's anticipated that logging will be handled through the generic slf4j interface. Implementation frameworks will be responsible to provide implementations of their choosing.</p>
<h3 id="what-about-metrics-tracing">What about metrics / tracing?</h3>
<p>This is an area that needs design, but can be done at a later date and does not affect the overall architecture of the USI.</p>
<h3 id="benchmarking">Benchmarking</h3>
<p>The USI will have a simple framework test harness used to benchmark its performance, independently, to avoid performance regressions.</p>
<h3 id="how-will-java-consume-this">How will Java consume this?</h3>
<p>The inputs and outputs will be exposed as reactive stream <a href="https://www.reactive-streams.org/reactive-streams-1.0.0-javadoc/org/reactivestreams/Publisher.html">Publishers</a> and <a href="https://www.reactive-streams.org/reactive-streams-1.0.0-javadoc/org/reactivestreams/Subscriber.html">Subscribers</a>. Reactive streams has been merged in to the standard library as of Java 9 and is available as a polyfill dependency for Java 8.</p>
<p>A Java interface will be provided for generating related data structures, interacting with constraints, reading <code>PodStatus</code> / <code>ReservationStatus</code>, etc.</p>
<h3 id="how-will-we-react-to-spikes-in-offers-received">How will we react to spikes in offers received</h3>
<p>The USI will queue a configurable number of offers. If this queue is exceeded, offers without reservations pertaining to the framework will be &quot;quick declined&quot;, without evaluation.</p>
<h3 id="how-will-reservations-be-labeled-associated-with-the-framework">How will reservations be labeled / associated with the Framework?</h3>
<p>Reservations for single role frameworks will be handled with labels. If needed, we will provide an pluggable strategy for detecting reservations belonging to us, and specifying them.</p>
<p>For multi-role reservations, we can explore using a framework-specific role (the framework ID?). This could in theory enable more efficient revives when trying to re-launch resident pods.</p>
<h3 id="how-will-offer-revive-be-handled">How will offer revive be handled?</h3>
<p>Offer revive will be automatically managed by the USI, as needed. However, there could be different revive policies needed (more aggressive, less aggressive, due to the framework?). Some investigation and further design is warranted here.</p>
<h3 id="how-do-you-restart-a-pod">How do you restart a pod?</h3>
<p>A pod is restarted by sending a Kill command for some pod id. Then, once USI reports said pod as terminal, send a command to expunge the podRecord, and send a command to launch a new pod.</p>
<h3 id="what-constraints-are-there-on-pod-task-ids">What constraints are there on Pod / task IDs?</h3>
<p>The USI, out of necessity, allows any valid task ID as a pod / task ID. Were it not so, frameworks could not move to the USI without killing all existing pods and reservations (since said IDs are immutable).</p>
<p>An option we can explore is providing modeled IDs to the USI, with one of the variants of the modeled ID being &quot;freeform&quot; (no associated metadata implied). Benefits of this approach could allow the USI to:</p>
<h3 id="how-does-the-usi-report-schema-violation-errors-to-the-framework">How does the USI report schema violation errors to the framework</h3>
<p>The Framework is responsible for sanitizing user input. Any failures to provide the USI valid input will be considered a bug.</p>
<p>If it does happen, one mechanism for reporting errors could be to output an erroneous podStatuses with the validation errors. This is an area open for further design.</p>
<h3 id="how-does-a-framework-resize-reservations">How does a Framework resize reservations?</h3>
<p>Reservations will be resized by specifying a new reservation spec for the same reservation ID. The status for the reservation will be exposed via the ReservationStatus on the other end, &quot;resizing&quot;, &quot;resize failed&quot;, etc.</p>
<h3 id="which-version-of-the-mesos-client-will-the-usi-use">Which version of the Mesos client will the USI use?</h3>
<p>The USI will use the Mesos v1 client</p>
<h3 id="is-leader-election-a-concern-of-the-unified-scheduler">Is leader election a concern of the unified scheduler?</h3>
<p>No.</p>
<h3 id="what-if-the-framework-wants-to-use-a-different-data-store-other-than-zookeeper">What if the framework wants to use a different data store, other than Zookeeper?</h3>
<p>Initially, the USI will be opinionated towards storing its state in Zookeeper. Theoretically, any persistence mechanism that can preserve the order of writes would work as well. A pluggable storage module could be introduced at a future point.</p>
<h3 id="why-not-just-auto-kill-something-for-which-a-podrecord-no-longer-exists">Why not just auto-kill something for which a podRecord no longer exists?</h3>
<p>This is the behavior that Marathon has historically had, and has led to upsetting problems when the persistent state comes invalid or out-of-date (for example, a backup is restored because an upgrade failed). Preferably, how to handle spurious tasks and reservations is up to the implementation framework.</p>
<h1 id="relevant-resources">Relevant Resources</h1>
<ul>
<li><a href="http://www.cqrs.nu/faq">CQRS Faq</a></li>
<li><a href="https://docs.google.com/presentation/d/11DFGBhWcEj3s7h1UT-adUbPQlea2K-PgYimySfQgb8k/edit?ouid=116111700009119528924&amp;usp=slides_home&amp;ths=true">Scheduler Loop Design Slides</a></li>
<li><a href="https://martinfowler.com/articles/lmax.html">Martin Fowler: The LMAX Architecture</a></li>
<li><a href="https://qconlondon.com/london-2012/qconlondon.com/dl/qcon-london-2012/slides/MartinThompson_and_MichaelBarker_LockFreeAlgorithmsForUltimatePerformance.pdf">Lock Fee Algorithms for Ultimate Performance Slides</a></li>
<li><a href="https://www.reactivemanifesto.org">Reactive Manifesto</a></li>
</ul>
</article>
</body>
</html>
