package com.mesosphere.usi.core
import com.mesosphere.usi.core.models.{
  AgentRecordUpdated,
  PodId,
  PodRecord,
  PodRecordUpdated,
  PodSpec,
  PodStatus,
  PodStatusUpdated,
  ReservationStatusUpdated,
  StateSnapshot
}

/**
  * Data structure that contains all the state used for the SchedulerLogic. It's state is manipulated through Effects,
  * so that the state can be reliably subscribed to by other components.
  *
  * @param podSpecs
  * @param podRecords
  * @param podStatuses
  */
case class Frame(podSpecs: Map[PodId, PodSpec], podRecords: Map[PodId, PodRecord], podStatuses: Map[PodId, PodStatus]) {

  /**
    * PodRecords, PodStatuses, and other state managed by USI is manipulated through effects, which are generated by
    * SchedulerLogic. This function takes those affects, applies them to the frame, and returns a new frame.
    */
  def applyStateEffects(effects: FrameEffects): Frame = {
    var newPodRecords = podRecords
    var newPodStatuses = podStatuses
    effects.stateEvents.foreach {
      case recordChange: PodRecordUpdated =>
        recordChange.newRecord match {
          case Some(newRecord) =>
            newPodRecords = newPodRecords.updated(recordChange.id, newRecord)
          case None =>
            newPodRecords -= recordChange.id
        }
      case statusChange: PodStatusUpdated =>
        statusChange.newStatus match {
          case Some(newStatus) =>
            newPodStatuses = newPodStatuses.updated(statusChange.id, newStatus)
          case None =>
            newPodStatuses -= statusChange.id
        }
      case agentRecordChange: AgentRecordUpdated => // TODO
      case reservationStatusChange: ReservationStatusUpdated => // TODO
      case statusSnapshot: StateSnapshot => // TODO
    }

    copy(podRecords = newPodRecords, podStatuses = newPodStatuses)
  }

}

object Frame {
  val empty = Frame(Map.empty, Map.empty, Map.empty)
}
