package com.mesosphere.usi.core
import com.mesosphere.usi.core.models._

/**
  * Data structure that contains all the state used for the SchedulerLogic. It's state is manipulated through Effects,
  * so that the state can be reliably subscribed to by other components.
  *
  * @param podRecords
  * @param podStatuses
  */
case class SchedulerState(
    podRecords: Map[PodId, PodRecord],
    podStatuses: Map[PodId, PodStatus],
    podSpecs: Map[PodId, PodSpec]) {

  /**
    * PodRecords, PodStatuses, and other state managed by USI is manipulated through effects, which are generated by
    * SchedulerLogic. This function takes those affects, applies them to the frame, and returns a new frame.
    *
    * The difference between a stateIntent and a stateEvent is semantic; a stateIntent has not yet been applied to the
    * frame state. Once it has, it is then a stateEvent and is used for external replication and persistence.
    */
  def applyStateIntents(stateIntents: List[StateEventOrSnapshot]): SchedulerState = {
    var newPodRecords = podRecords
    var newPodStatuses = podStatuses
    var newPodSpecs = podSpecs
    stateIntents.foreach {
      case recordChange: PodRecordUpdatedEvent =>
        recordChange.newRecord match {
          case Some(newRecord) =>
            newPodRecords = newPodRecords.updated(recordChange.id, newRecord)
          case None =>
            newPodRecords -= recordChange.id
        }
      case statusChange: PodStatusUpdatedEvent =>
        statusChange.newStatus match {
          case Some(newStatus) =>
            newPodStatuses = newPodStatuses.updated(statusChange.id, newStatus)
          case None =>
            newPodStatuses -= statusChange.id
        }
      case agentRecordChange: AgentRecordUpdatedEvent => ???
      case stateSnapshot: StateSnapshot =>
        // TODO (DCOS-47476) Implement cache invalidation and handle snapshot fully
        newPodRecords = stateSnapshot.podRecords
          .foldLeft(newPodRecords)((acc, record) => acc.updated(record.podId, record))
      case PodSpecUpdatedEvent(id, newState) =>
        newState match {
          case Some(podSpec) =>
            newPodSpecs = podSpecs.updated(id, podSpec)
          case None =>
            newPodSpecs -= id
        }
      case _: PodInvalid => ???
    }

    copy(podRecords = newPodRecords, podStatuses = newPodStatuses, podSpecs = newPodSpecs)
  }

}

object SchedulerState {
  val empty = SchedulerState(Map.empty, Map.empty, Map.empty)
  def fromSnapshot(snapshot: StateSnapshot): SchedulerState = {
    apply(
      podStatuses = Map.empty,
      podRecords = snapshot.podRecords.map(record => record.podId -> record)(collection.breakOut),
      podSpecs = Map.empty)
  }
}
