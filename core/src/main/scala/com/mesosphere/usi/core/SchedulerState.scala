package com.mesosphere.usi.core
import com.mesosphere.usi.core.models._

/**
  * Data structure that contains all the state used for the SchedulerLogic. It's state is manipulated through Effects,
  * so that the state can be reliably subscribed to by other components.
  *
  * @param podRecords
  * @param podStatuses
  */
case class SchedulerState(podRecords: Map[PodId, PodRecord], podStatuses: Map[PodId, PodStatus]) {

  /**
    * PodRecords, PodStatuses, and other state managed by USI is manipulated through effects, which are generated by
    * SchedulerLogic. This function takes those affects, applies them to the frame, and returns a new frame.
    *
    * The difference between a stateIntent and a stateEvent is semantic; a stateIntent has not yet been applied to the
    * frame state. Once it has, it is then a stateEvent and is used for external replication and persistence.
    */
  def applyStateIntents(stateIntents: List[StateEvent]): SchedulerState = {
    var newPodRecords = podRecords
    var newPodStatuses = podStatuses
    stateIntents.foreach {
      case recordChange: PodRecordUpdated =>
        recordChange.newRecord match {
          case Some(newRecord) =>
            newPodRecords = newPodRecords.updated(recordChange.id, newRecord)
          case None =>
            newPodRecords -= recordChange.id
        }
      case statusChange: PodStatusUpdated =>
        statusChange.newStatus match {
          case Some(newStatus) =>
            newPodStatuses = newPodStatuses.updated(statusChange.id, newStatus)
          case None =>
            newPodStatuses -= statusChange.id
        }
      case agentRecordChange: AgentRecordUpdated => ???
      case reservationStatusChange: ReservationStatusUpdated => ???
      case statusSnapshot: StateSnapshot =>
        if (statusSnapshot.podRecords.nonEmpty) {
          newPodRecords = statusSnapshot.podRecords
            .foldLeft(newPodRecords)((acc, record) => acc.updated(record.podId, record))
        }
    }

    copy(podRecords = newPodRecords, podStatuses = newPodStatuses)
  }

}

object SchedulerState {
  val empty = SchedulerState(Map.empty, Map.empty)
}
